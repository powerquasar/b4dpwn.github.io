{"meta":{"title":"powerquasar's blog","subtitle":"","description":"","author":"John Doe","url":"http://powerquasar.github.io","root":"/"},"pages":[{"title":"categories","date":"2022-05-05T02:53:56.000Z","updated":"2022-05-05T02:54:38.339Z","comments":true,"path":"categories/index-1.html","permalink":"http://powerquasar.github.io/categories/index-1.html","excerpt":"","text":""},{"title":"categories","date":"2022-05-05T02:16:30.000Z","updated":"2022-05-05T02:16:30.188Z","comments":true,"path":"categories/index.html","permalink":"http://powerquasar.github.io/categories/index.html","excerpt":"","text":""},{"title":"tags","date":"2022-05-05T02:52:02.000Z","updated":"2022-05-05T02:52:55.178Z","comments":true,"path":"tags/index.html","permalink":"http://powerquasar.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"litCTF2022re","slug":"litCTF2022re","date":"2022-07-27T22:21:30.000Z","updated":"2022-07-27T22:59:23.786Z","comments":true,"path":"2022/07/28/litCTF2022re/","link":"","permalink":"http://powerquasar.github.io/2022/07/28/litCTF2022re/","excerpt":"","text":"虽然赛题比较简单，但这里还是记录一下 第一道题math 打开程序是这样的，我们直接看grade_test(一看就知道判断flag的) 可以看到就是简单的把输入与answers数组里面的内容作对比 直接看answer中的内容 可以看到已经初始化好了，直接运行程序输入即可 get flag 第二题也是一道简单题，这里直接偷懒了，没有分析算法，用大佬推荐的angr直接一把梭了。。。 angr具体的安装和用法可自行搜索 但回过头来分析，其实也不难 也就是两个数组里面的值相加等于输入，转为字符即可 第三题 打开一看，有些懵，查了下~用法，原来，这里是取反运算符。程序逻辑不难，又有明显的关键字，所以直接angr一把梭 总结：angryyds，它能够帮助我们不需要分析程序算法，快速解决逻辑简单的问题。","categories":[],"tags":[{"name":"reverse","slug":"reverse","permalink":"http://powerquasar.github.io/tags/reverse/"}]},{"title":"DASCTF7月赋能赛隐藏的角落","slug":"DASCTF20227re","date":"2022-07-26T04:17:11.000Z","updated":"2022-07-27T04:53:50.846Z","comments":true,"path":"2022/07/26/DASCTF20227re/","link":"","permalink":"http://powerquasar.github.io/2022/07/26/DASCTF20227re/","excerpt":"","text":"查看程序为64位elf文件，并使用go语言编写。用ida647.7打开。 直接定位到checkflag 进入main_Myencode函数 可以明显看到是rc4加密 然后动调获取key或者s盒 注：这里踩了一个坑 一开始以为密文就放在了main_enc里面。导致接出来是一串乱码 其实这里需要动态调试 经过测试，这里需要输入二十九个字符才能断下来 断下来之后再f8两次 可以看到s盒已经为我们初始化好了 用ida脚本提取即可 然后重新运行程序 注：经过调试，发现只能在加密函数那里下断点，在后面的两个位置下断点程序会崩溃。（呜呜呜，本菜鸡也不知道为啥，有知道的师傅可以在下方评论区留言） 然后提取main_enc的值时，可以发现，此时的值与之前的不一样了。之前的值就是个烟雾弹。。。 然后提取，写出解密脚本 import base64 s=[0x92, 0xDD, 0x48, 0x62, 0xB9, 0x91, 0xE2, 0x86, 0xF9, 0x76, 0x27, 0x6A, 0x49, 0x4E, 0xD2, 0x7D, 0xC7, 0x43, 0xC9, 0x42, 0xB3, 0xCD, 0xD5, 0x6E, 0x10, 0xC2, 0xD0, 0x5F, 0xF5, 0x69, 0xFA, 0x82, 0x3B, 0xCB, 0x2E, 0xBC, 0x54, 0x1B, 0xA4, 0xCE, 0x30, 0x37, 0xD9, 0x4D, 0x64, 0x3C, 0xDA, 0x5D, 0x38, 0x2C, 0x8E, 0x20, 0xB4, 0x55, 0xFE, 0x58, 0x3E, 0x8D, 0x32, 0xEE, 0xD7, 0x85, 0x34, 0x99, 0x28, 0xEA, 0x60, 0xFF, 0x21, 0x53, 0x2B, 0xC3, 0xE, 0x72, 0x90, 0xE3, 0x5E, 0xA6, 0x29, 0x9C, 0xDC, 0xBE, 0xBD, 0x6B, 0x15, 0xDE, 0xB2, 0x0, 0x8F, 0xFB, 0xA2, 0x7F, 0x74, 0x1A, 0x83, 0xE1, 0x63, 0x23, 0xF3, 0xF0, 0x2, 0x1E, 0x9E, 0xA7, 0x50, 0xD1, 0xCF, 0x6C, 0x71, 0x79, 0x13, 0x8, 0x88, 0x8B, 0x1, 0x25, 0x67, 0x80, 0xC4, 0xEF, 0x45, 0x41, 0x52, 0x6D, 0xAE, 0x4C, 0xF, 0xEC, 0x87, 0xAF, 0x7E, 0x97, 0x35, 0xF6, 0x81, 0xE5, 0x9B, 0xD, 0xE7, 0x2D, 0x5A, 0xC1, 0xA9, 0x51, 0xDB, 0x6F, 0x8A, 0xB1, 0x98, 0x73, 0xAC, 0x4F, 0x65, 0xAD, 0x7, 0x7B, 0x18, 0xE9, 0xF1, 0xDF, 0xB8, 0x5, 0xB0, 0x11, 0x70, 0xE6, 0xC5, 0x17, 0x12, 0x16, 0x3A, 0x44, 0x6, 0x8C, 0xE8, 0x31, 0x75, 0x3, 0x9A, 0xFD, 0x61, 0x3F, 0x2A, 0xF8, 0xD8, 0x46, 0x39, 0xBF, 0x78, 0xA8, 0xF4, 0xA, 0x4, 0xE4, 0x57, 0xB6, 0x22, 0x84, 0xE0, 0xF7, 0xC8, 0x7A, 0x1C, 0xA1, 0x5C, 0xC0, 0x7C, 0xC, 0xC6, 0x36, 0xB5, 0xCC, 0xD6, 0xBA, 0x9, 0xFC, 0xBB, 0x68, 0x96, 0x47, 0x1F, 0x4A, 0x9D, 0xED, 0x95, 0xA5, 0x93, 0xD4, 0xCA, 0xAA, 0x26, 0xB, 0x5B, 0x40, 0xB7, 0x66, 0x56, 0xAB, 0x33, 0xA0, 0x9F, 0xF2, 0x59, 0x89, 0x1D, 0x19, 0x3D, 0x94, 0x24, 0xA3, 0xEB, 0xD3, 0x2F, 0x77, 0x14,0x4B ] enc=[ 0xFB, 0xC6, 0xA6, 0x9D, 0xC4, 0xDB, 0x7B, 0x56, 0xB6, 0x46, 0xA6, 0xC0, 0x85, 0x64, 0x7A, 0x9A, 0x37, 0x4C, 0x10, 0x96, 0xE9, 0xA7, 0x28, 0xC4, 0xB1, 0x2D, 0xF1, 0xDE, 0x47, 0x3B, 0xB5, 0xF3, 0x2C, 0x7D, 0x67, 0x1D] i=0 j=0 t=0 for k in range(len(enc)): i=(i+1)%256 j=(j+s[i])%256 tmp=s[i] s[i]=s[j] s[j]=tmp t=(s[i]+s[j])%256 enc[k]^=s[t] flag=&#39;&#39; for i in range(len(enc)): flag+=chr(enc[i]) print(flag) #56e83694-f976-11eb-b343-faffc201c8e0 然后根据题意，将得到的值md5一下，然后再包上DASCTF{}即可 完结，撒花","categories":[],"tags":[{"name":"reverse","slug":"reverse","permalink":"http://powerquasar.github.io/tags/reverse/"}]},{"title":"HSCTF-9","slug":"HSCTF-9","date":"2022-06-13T13:35:41.000Z","updated":"2022-07-28T01:32:17.752Z","comments":true,"path":"2022/06/13/HSCTF-9/","link":"","permalink":"http://powerquasar.github.io/2022/06/13/HSCTF-9/","excerpt":"","text":"下载下来附件后是这样一个简单的python程序 state = 1 flag = &quot;[REDACTED]&quot; alphabet = &quot;abcdefghijklmnopqrstuvwxyz&quot; ciphertext = &quot;&quot; for character in flag[5:-1]: state = (15*state+18)%29 ciphertext+=alphabet[(alphabet.index(character)+state)%26] print(ciphertext) #mawhxyovhiiupukqnzdekudetmjmefkqjgmqndgtnrxqxludegwovdcdmjjhw（这是题目描述给的） 直接解 state = 1 flag = &quot;&quot; alphabet = &quot;abcdefghijklmnopqrstuvwxyz&quot; ciphertext = &quot;mawhxyovhiiupukqnzdekudetmjmefkqjgmqndgtnrxqxludegwovdcdmjjhw&quot; for i in ciphertext: state = (15*state+18)%29 flag+=alphabet[(alphabet.index(i)-state)%26] print(flag) #iguessthisiswhatyouwouldcallalinearcongruentialvigenerecipher 得到我们的flag,然后根据题目要求再包上flag{}","categories":[],"tags":[{"name":"crypto","slug":"crypto","permalink":"http://powerquasar.github.io/tags/crypto/"}]},{"title":"ctfshow1","slug":"ctfshow1","date":"2022-05-06T02:07:07.000Z","updated":"2022-05-06T02:07:44.451Z","comments":true,"path":"2022/05/06/ctfshow1/","link":"","permalink":"http://powerquasar.github.io/2022/05/06/ctfshow1/","excerpt":"","text":"","categories":[],"tags":[{"name":"ctfshowpwn","slug":"ctfshowpwn","permalink":"http://powerquasar.github.io/tags/ctfshowpwn/"}]},{"title":"pwn enter the door","slug":"pwn-enter-the-door","date":"2022-05-05T05:45:30.000Z","updated":"2022-05-05T07:09:32.213Z","comments":true,"path":"2022/05/05/pwn-enter-the-door/","link":"","permalink":"http://powerquasar.github.io/2022/05/05/pwn-enter-the-door/","excerpt":"","text":"#入门：elf文件，汇编指令，c语言编程基础 栈部分前提，理解函数调用栈的运作机制：https://www.bilibili.com/video/BV1Cv411T7W3?from=search&amp;seid=5444614129123787600&amp;spm_id_from=333.337.0.0这里可以选集，ppt很形象（1）栈溢出：程序在创建局部变量或进行函数调用时的同时会申请一块与其数据类型对应的内存，这个内存我们称之为栈，栈是一种先入后出的数据结构，就好比往一个瓶子里放东西，先放进去的后出来。详细函数调用栈的内容看上面的链接。栈溢出指的是程序向栈中某个变量中写入的字节数超过了这个变量本身所申请的字节数，因而导致与其相邻的栈中的变量的值被改变。类似的还有堆溢出，bss 段溢出等溢出方式。栈溢出漏洞轻则可以使程序崩溃，重则可以使攻击者控制程序执行流程。整形是4个字节以计算，char型一字节一计算发生栈溢出的基本前提是：首先程序必须向栈上写入数据写入的数据大小没有被良好的控制最典型的栈溢出利用是覆盖程序的返回地址为攻击者所控制的地址，当然需要确保这个地址所在的段具有可执行权限。往栈上写入数据是从低地址往高地址写的，也就是说如果我们覆盖了ebp(32位下)/rbp(64位下)即函数的栈底指针的值，我们就可以篡改其后的返回地址为我们想要实现的函数的地址。常见的危险函数：gets:直接读取一行，忽略\\x00,并且遇到\\n才结束读取。 **scanf:遇到\\n就会结束，但如果下面的还是输入，就会把\\n放到下面，导致下面的输入被直接跳过了** **printf:不会在结尾处加上\\0** **strcpy，字符串复制，遇到&#39;\\x00&#39;停止** **strcat，字符串拼接，遇到&#39;\\x00&#39;停止** 格式化字符串漏洞: 原理：当我们使用printf打印字符串时，我们一般设置其第一个参数为格式化字符串，后面的参数为格式化字符串要表示的变量。而当我们直接将后面的变量当作printf的第一个参数传入时，程序非但没有报错，而且还正常运行了，这是怎么回事呢？其实这是因为printf函数并不知道参数个数，它的内部有个指针，⽤来索检格式化字符串。对于特定类型%，就去取相应参数的值，直到索检到 格式化字符串结束。 所以尽管没有参数，上⾯的代码也会将format string 后⾯的内存当做参数以16进制输出。这样就会造成内存泄露。 而这种情况只是在用户输入下才会发生。","categories":[],"tags":[{"name":"pwn","slug":"pwn","permalink":"http://powerquasar.github.io/tags/pwn/"}]},{"title":"我的第一篇博客，hello hexo","slug":"我的第一篇博客，hello-hexo","date":"2022-05-04T10:10:47.000Z","updated":"2022-05-04T10:10:47.263Z","comments":true,"path":"2022/05/04/我的第一篇博客，hello-hexo/","link":"","permalink":"http://powerquasar.github.io/2022/05/04/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2%EF%BC%8Chello-hexo/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Hello World","slug":"hello-world","date":"2022-05-04T10:01:12.757Z","updated":"2022-05-04T10:00:49.070Z","comments":true,"path":"2022/05/04/hello-world/","link":"","permalink":"http://powerquasar.github.io/2022/05/04/hello-world/","excerpt":"","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post$ hexo new &quot;My New Post&quot; More info: Writing Run server$ hexo server More info: Server Generate static files$ hexo generate More info: Generating Deploy to remote sites$ hexo deploy More info: Deployment","categories":[],"tags":[]}],"categories":[],"tags":[{"name":"reverse","slug":"reverse","permalink":"http://powerquasar.github.io/tags/reverse/"},{"name":"crypto","slug":"crypto","permalink":"http://powerquasar.github.io/tags/crypto/"},{"name":"ctfshowpwn","slug":"ctfshowpwn","permalink":"http://powerquasar.github.io/tags/ctfshowpwn/"},{"name":"pwn","slug":"pwn","permalink":"http://powerquasar.github.io/tags/pwn/"}]}